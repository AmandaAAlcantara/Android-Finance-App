**Mobile Development 2023/24 Portfolio**
# API description

Student ID: `22083120`

Focusing on the transaction functionality of my app, where the user can add income and expenses. I chose to use ConstraintLayout for the activity_add_transaction XMl from the start, as I knew the different input options would grow as I developed this feature, and ensuring the UI would be adaptable was a priority - the new user needs to input information (form format). To expand, ConstraintLayout offers flexible and efficient positioning of UI elements, specifically allowing them to be aligned and distributed relative to each other and the parent. Therefore, making it easier to create the layouts for the different TextInput,  improving the performance and maintainability of the UI for different size phones. Despite the possible use of LinearLayout or RelativeLayout, the ConstraintLayout was the optimal choice considering the 5 elements that need to be positioned, the use was not over-engineered.

In addition, View API  in the TransactionAdapter class played a crucial role in delivering the list of transactions when a new one was created, ensuring consistency and compatibility with the RecyclerView framework. Accordingly, the use of view in this context allows for straightforward manipulation within RecyclerView items, facilitating tasks such as view initialization, interaction handling, and layout inflation (as I had to add new transaction items and be able to edit them as well). More specifically, the TransactionHolder class is a ViewHolder for RecyclerView items responsible for holding references to views, within each transaction layout. Hence, the choice to use View as the parameter type for the ViewHolder constructor is correct since it represents the root view of each item. Moreover, inside the ViewHolder constructor (TransactionHolder), the views TextViews (label and amount) are initialized using findViewById. Since these views are part of the layout inflated for each item, it's logical to use View as the parameter type to access and manipulate these specific views. 

<!-- 
Feedback from Sandy

i) Your description of the choice of ConstraintLayout is good, although perhaps there is a little too much detail on how exactly it works without it being clearly related to your implementation. So you describe the flexibility/efficiency of the ConstraintLayout, but it's not so clear how you've made use of this in your app. It seems that you could only have achieved your layout with ConstraintLayout, but that's not the only reason you could've used it over the alternatives. If you can shorten this section somewhat and be clearer about your choices in relation to the functionality you'd need, that'd be good. (If your implementation was about future proofing, then that is also a reasonable decision too, even if in the current iteration you could've used, say, a LinearLayout.)

ii) I think the section on your RecyclerView is perhaps a little heavy on describing how it works and less on your usage. In some senses you're a little limited here, because you have to follow the MVVM pattern when putting in a RecyclerView – you are quite limited in terms of what you can 'choose' or control. You want a RecyclerView, you have to build in this pattern. I think you can significantly shorten this section and that would give you more space to describe and discuss other aspects of the API choices that you made. Maybe there is something to say about how you have stored persistent data, for example? 

iii) You're already four words over limit – you will need to try and get the text a little tighter!

I hope this helps. You're on the right lines, and I appreciate the depth, but it's important that the depth is helping you demonstrate how you've thought about the development, and not just a description of how things work. 
-->